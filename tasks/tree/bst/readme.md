# Бинарное дерево поиска

## Пререквизиты

- [lists/list](/tasks/lists/list)

---

В этой задаче напишем свой [словарь](https://docs.python.org/3/tutorial/datastructures.html#dictionaries), более известный как `map`

---

*BST* – структура данных, которая выполняет операции поиска, вставки, удаления **в среднем** за O(log n).

**Обладает следующими свойствами:**
- Максимум 2 ребёнка (бинарное дерево).
- Ключ левого ребёнока меньше текущего.
- Ключ правого ребёнока больше текущего.

За счёт двух последних свойств может применяться [бинарный поиск](https://agorinenko.github.io/data-structures-and-algorithms/tutorial/binary_search.html). Слева элементы всегда меньше, справа - больше.

У каждого узла есть ключ (`Key`) по которому происходит поиск и значение (`Value`), которое хранится в структуре.

Основные операции: 
- Вставка элемента: `void Insert(const std::pair<const Key, Value>&)`
- Удаление элемента: `void Erase(const Key&)`
- Поиск элемента: `bool Find(const Key&)`

### `Insert`

На вход принимает `std::pair<const Key, Value>`

См. [std::pair](https://en.cppreference.com/w/cpp/utility/pair)

Обратите внимание, что первый элемент в pair `const Key`, а не просто `Key`!

Алгоритм можно разбить на три шага:
1) Найти позицию для вставки бинарным поиском
2) Создать новый узел с вставляемыми данными
3) Связать новый узел с узлом из пункта 1

Если данный ключ уже есть в дереве - перезаписываем данные.

### `Erase`
На вход принимает ключ, по которому нужно найти узел для удаления.

Алгоритм можно разбить на три шага:
1) Найти родителя удаляемого узла</br>
    `a)` **У удаляемого узла нет детей (он лист)**</br>
        - Удаляем, указатель у родителя переводим в nullptr</br>
    `b)` **У удаляемого узла есть только левый сын**</br>
        - Связываем родителя с левым сыном</br>
    `c)` **У удаляемого узла есть только правый сын**</br>
        - Связываем родителя с правым сыном</br>
    `d)` **У удаляемого узла есть оба ребёнка**</br>
        - На место удаляемого узла помещаем минимальный элемент в данном поддереве</br>
3) Удалить указанный узел

Если узел не найден, бросьте исключение `std::runtime_error`:
```C++
throw std::runtime_error("Value not found");
```


### `Find`
На вход принимает ключ, по которому нужно найти узел.

Возвращаем bool: `true`, если значение есть, `false` - если нет.

Алгоритм можно описать так:
1) Если текущий корень == `nullptr` - возвращаем `false`.
2) Если искомый ключ меньше текущего - идём влево.
3) Если искомый ключ больше текущего - идём вправо.
4) Если искомый ключ равен текущему - возвращаем `true`.

## Словарь в `std`

См. [std::map](https://en.cppreference.com/w/cpp/container/map)

### Red-Black Tree

Стоит отметить, что сложность операций будет O(log n) **в среднем**. Однако, если вставлять отсортированные элементы, дерево может выстраиваться в `лесенку`: </br></br>
![Alt text](images/image.png)

В таком случае все операции станут выполняться за `O(N)`.

Чтобы этого избежать существуют `сбалансированные деревья поиска` - дерево, в котором высоты любого левого и правого поддерева отличаются не более чем на 1. 

Путём дополнительных операций `балансировки`, достигается `O(log n)` во всех случаях.

Именно эти деревья реализованы в `std::map` и `std::set`.

См. [std::set](https://en.cppreference.com/w/cpp/container/set)

## Задание

Реализуйте [словарь](map.hpp) с помощью бинарного дерева поиска.

### Указания к реализации

Во всех операциях используется поиск. Подумайте над тем, как можно избавиться от дублирования кода в этих местах.

`Запрещено хранить указатель на родителя в Node!`

**В публичное API не стоит добавлять новых методов!**

**В публичном API не должно быть класса `Node`!** 

`Compare` - это функция, которая возвращает true, если первый элемент меньше второго. В `std::map` пользователь может задать свою собственную функцию сравнения объектов. Вместо операторов `<` или `>` используйте функцию `Compare(val1, val2)`.

`std::initializer_list` позволяет передавать список элементов.</br>
[How to create a constructor initialized with a list?](https://stackoverflow.com/questions/21869208/how-to-create-a-constructor-initialized-with-a-list)

`Values` возвращает пользователю [`std::vector`](https://en.cppreference.com/w/cpp/container/vector) пар ключ-значение. Принимает булевский параметр `is_increase`. Если он `true` - данные в векторе должны быть упорядочены по возрастанию, если `false` - по убыванию.


## References
- [std::less](https://en.cppreference.com/w/cpp/utility/functional/less)
- [Why `std::pair` is smelly](https://arne-mertz.de/2017/03/smelly-pair-tuple/)
- [Red-Black Tree](https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/)

## Примечание

В деревьях из `std` применяются итераторы. У вас будет возможность реализовать их позже в задаче [iterators](../iterators)